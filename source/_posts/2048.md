---
title: 2048
date: 2017-08-25 14:54:01
tags: [2048,react,移动端]
categories: 技术分享
---

# 用React编写2048
<strong>原创文章,转载请著名,谢谢Thanks♪(･ω･)ﾉ<strong>
***

## 准备工作
1. 需要一个搭配好的脚手架,这里我放上我用的<big>☞</big>[Go](https://coding.net/u/Dcison/p/webpack/git)
2. 在这脚手架上还用了Pubsub.Js (纯属好玩,可以不需要安装,但是代码得自己改改)
3. 移动端用到了jquery.swipe.js,等会说
***
<!-- more -->

## 目录结构
* 2048(根目录)
  * build (最后打包完成的文件目录)
  * src (主要编写代码的地方)
    * main.js (打包入口的文件)
    * jquery.swipe.js (用于移动端)
    * components (组件目录)
        * assets (静态资源目录，放的是less)
            * app.less
        * js 
            * <strong>app.js<strong> (我们主要代码的文件)
  * index_tpl.html (html模板)
  * 。。。(剩下的就省略不说了,是webpack相关的知识了)
***

## main.js(入口文件的代码)
```javascript
import React from 'react';
import ReactDom from 'react-dom';
import App from './components/js/app';
import Pubsub from 'pubsub-js';
class Main extends React.Component {
  componentDidMount(){
    Pubsub.subscribe('WIN', () => {
      alert("你赢了");
      location.reload();
    });
    Pubsub.subscribe('OVER', () => {
      alert("你输了");
      location.reload();
    });
  }
  componentWillUnmount(){
    Pubsub.unsubscribe('WIN');    
    Pubsub.unsubscribe('OVER');    
  }
  render() {
    return (
      <App/>
    )
  }
};
ReactDom.render(<Main />, document.getElementById('app'));
```
首先就是引入该引入的文件，然后用ReactDom渲染，都是React常识了
说一下Pubsub,这里接受子组件传来的消息:1. win 2. game over,然后分别处理(其实就是弹窗( :3 )),然后强制刷新。可以不用Pubsub,直接在APP的组件里处理胜负。
***

## app.js (重头戏)
首先分析下2048需要什么功能:
1. 首要的肯定是渲染出界面吧(4*4个格子)
2. 能玩!(上下左右移动/触摸移动格子)
3. 分数展示
4. 能判断胜负

### 第一个功能
标题，分数展示就不说了，主要讲如何创建16个格子，而且随机初始化两个格子位置
```javascript
import React from 'react';
import '../assets/app.less';
import Pubsub from 'pubsub-js';
class App extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            score: 0, //初始分数为0
            arr: [], //放16个格子的数组
            moveable: false //格子是否可以移动,后面说
        };
    }
    render() {
        let mes;
        mes = this.state.arr.map((item) => {
            return (
                item.map((i) => {
                    return (
                        <div className={`game-item-${i}`} id="phone" >
                            {`${i > 0 ? i : ""}`}
                        </div>)
                })
            )
        })
        return (
            <div>
                <div className="title">2048</div>
                <div>Score: <span className="score">{this.state.score}</span></div>
                <div className="game-box">
                    {mes}
                </div>
            </div>
        )
    }
}
export default App;
```

首先是render渲染title:2048、分数:score,score值绑定里state里的score,然后是mes: 16个格子,主要就是用map遍历二维数组,得到里面的值,将里面的值>0的格子渲染出来，并且用ES6模板语言,设置了classname随格子的值变化,就不用在每次移动格子之后去操作css了 
然后是初始化

``` javascript
    componentWillMount() {
            this.initRandom();
    }
```

调用随机生成函数生成2组不同的下标，传给真正的初始化函数init

``` javascript
init(i1, i2, j1, j2) {
        var i, j, array = [];
        for (i = 0; i < 4; i++) {
            array[i] = [];
            for (j = 0; j < 4; j++) {
                array[i][j] = 0;
            }
        }
        //80%初始为2,20%为4
        if(Math.floor(Math.random() * 10)>8){
            array[i1][j1] = 4;
        }else{
            array[i1][j1] = 2;
        }
        if(Math.floor(Math.random() * 10)>8){
            array[i2][j2] = 4;
        }else{
            array[i2][j2] = 2;
        }        
        this.setState({
            arr: array
        });
    }
```

一开始就先创建16个空格子(值都为0),然后用随机数，随机生成4或者2，这里用8:2的概率,然后用initRandom传来的随机两组下标赋值，这样我们的展示页应该就好了
![页面](http://wx3.sinaimg.cn/mw690/006m1w1Agy1fiw0ouba63j30n80or74d.jpg)
当然这里页面是写过less了

### 第二个功能
能玩就是能移动格子,这里我用到的是[liusaint1992](http://blog.csdn.net/liusaint1992/article/details/51549596)的方法
```javascript
    keyboardMonitor(e) {
        switch (e.keyCode) {
            case 38://上
                this.setState({
                    moveable: false
                })
                this.moveUp();
                this.checkLose();
                break;
            case 39://右
                this.setState({
                    moveable: false
                })
                this.moveRight();
                this.checkLose();
                break;
            case 40://下
                this.setState({
                    moveable: false
                })
                this.moveDown();
                this.checkLose();
                break;
            case 37://左
                this.setState({
                    moveable: false
                })
                this.moveLeft();
                this.checkLose();
                break;
            default:
                break;
        }
    }
    componentDidMount() {
        let that = this
        document.addEventListener('keyup', that.keyboardMonitor.bind(that))
    }
    componentWillUnmount() {
        document.removeEventListener('keyup', this.keyboardMonitor.bind(this))
    }
```
首先在componentDidMount()里绑定键盘事件--交给keyboardMonitor这个函数去完成,这里绑定后面一定要加bind(that) 否则获取不到键盘事件
keyboardMonitor函数就简单了,判断你动了键盘的什么键(e.keyCode里)然后分别调用函数就好了
接下来讲<strong>移动方法</strong>(算是核心算法了吧)
```javascript
 moveLeft() {
        var i, j, k, n, array = this.state.arr;
        for (i = 0; i < 4; i++) {
            n = 0;
            for (j = 0; j < 4; j++) {
                if (array[i][j] != 0) {
                    k = j - 1;
                    while (k >= n) {
                        if (array[i][k] == 0) {
                            if (k == n || (array[i][k - 1] != 0 && array[i][k - 1] != array[i][j])) {
                                array[i][k] = array[i][j];
                                array[i][j] = 0;
                                this.setState({
                                    moveable: true
                                })
                            }
                            k--;
                        } else {
                            if (array[i][k] == array[i][j]) {
                                n++;
                                var temp = array[i][k] * 2;
                                array[i][k] = temp;
                                if (temp == 2048) { Pubsub.publish("WIN"); }
                                array[i][j] = 0;
                                this.setState({
                                    moveable: true,
                                    score: this.state.score += temp
                                });
                            }
                            break;
                        }
                    }
                }
            }
        }
        if(this.state.moveable){
            this.setState({
                arr: array
            })
            this.newCell();
        }       
        
    }
```

以左移为例,思路是把一行取出来,然后从左往右遍历我们格子的数组,当碰上不为0的数(if (array[i][j] != 0)),对它进行操作:
* n 表示的是最左边可以到达的位置
* 从它的前一位( k = j - 1; )遍历
* 先说如果它的前一位不是0,那好办,判断它们是不是相等,相等则合并,然后n+1,合并代码自己看吧,很简单的,合并后判断合并后的值是不是2048,即是否胜利,如果不是则更新分数、移动的标记
* 如果是0,再判断它不是可以到达的最左边(左移嘛，当然是最左边),通过n和k之间的比较 and 要移动项和<strong>k项的前一项</strong>比较
* 比较完后通过判断移动的标记,移动过了就表示数组肯定要更新,要生成新的格子

### 生成格子

``` javascript
newCell() {
        var i, j, array = this.state.arr,index=[],temp;
        //生成格子前遍历是否还有空格子
        for (i = 0; i < 4; i++) {
            for (j = 0; j < 4; j++) {
                if (array[i][j] == 0) {
                    index.push([i,j]);
                }
            }
        }
        //如果还有空格子就证明游戏没有结束
        if (index.length>0) {
            temp = Math.floor(Math.random() * index.length );
            i = index[temp][0];
            j = index[temp][1];
            if(Math.floor(Math.random() * 10)>8){
                array[i][j] = 4;
            }else{
                array[i][j] = 2;
            }             
            this.setState({
                arr: array
            });
        }
    }
```

这个就不说了,有注释应该能看懂了
然后就是判断胜负的函数

### 胜负判断

``` javascript
    checkLose() {
        var i, j, temp, array = this.state.arr;
        for (i = 0; i < 4; i++) {
            for (j = 0; j < 4; j++) {
                temp = array[i][j];
                if (temp == 0) {
                    return;
                }
                if ((array[i + 1] != undefined) && (array[i + 1][j] == temp)) {
                    return;
                }
                if ((array[i][j + 1] != undefined) && (array[i][j + 1] == temp)) {
                    return;
                }
            }
        }
        PubSub.publish("OVER");
    }
```

以下分别对应各个if条件
* 只要还有空格子就没输
* 相邻<strong><big>列</big></strong>的行之间只要还有相同的就没输
* 相邻<strong><big>行</big></strong>的列之间只要还有相同的就没输
至于第二个条件为什么不写array[i + 1][j] != undefined因为此时array[i+1]为定义,直接用array[i+1][j]判断是会报错的

### 添加移动端功能

这里我用到的是[老白干](http://blog.csdn.net/pvfhv/article/details/3449803)独立出来的jquery.swipe.js
用法:
* 在html_tpl里引用jquery
    ``` HTML
        <body>
        <div id = "app"></div>   
        <script src="https://cdn.bootcss.com/jquery/2.1.1/jquery.min.js"></script>
        </body>
    ```
在webpack入口里引入jquery.swipe.js,更改一下入口配置
``` javascript
    entry: {
            index: [           
                path.resolve(__dirname,'./src/jquery.swipe.js'),
                path.resolve(__dirname, './src/main.js')
            ]        
    },
```
至此,jquery.swipe.js需要的环境就配好了,用法:
```javascript
componentDidMount() {
        let that = this;
        $('body').swipe({
            left: function(){
                that.setState({
                    moveable: false
                })
                that.moveLeft();
                that.checkLose();
            },
            right: function(){
                that.setState({
                    moveable: false
                })
                that.moveRight();
                that.checkLose();
            },
            up: function(){
                that.setState({
                    moveable: false
                })
                that.moveUp();
                that.checkLose();
            },
            down: function(){
                that.setState({
                    moveable: false
                })
                that.moveDown();
                that.checkLose();
            }
        });
    }
```
有了键盘监听的经验,这里应该就不难了
***

### 结束语

* 本文参考的主要核心写法是用了[liusaint1992](http://blog.csdn.net/liusaint1992/article/details/51549596)
* 项目地址:
    * [PlayGame](https://dcison.coding.me/2048Game/)
    * [Coding地址](https://coding.net/u/Dcison/p/2048Game/git)
* less就不说了,样式这东西,按自己喜好来吧