---
title: 谈谈原型链、原型、继承、执行上下文及作用域链的关系
date: 2018-03-20 14:09:08
tags: [js]
categories: 笔记
---

## 前文

	我相信很多人知道原型链、原型、继承、执行上下文、作用域等等关键名词，但是如何解释他们呢？而且这些又是面试必问题，这就需要我们对它有充足的理解，而不是强行的背诵。本文会打算以比较通俗的例子去讲解下这几个的关系。

<!-- more -->

## 原型、原型链

	一个对象里，默认有以下两个属性：
1.  \__proto\__ 姑且称它为原型指针
2. prototype 这个是原型对象
按照我的理解，原型应该就是指原型对象，原型链即通过原型指针__proto__ 找到它的**继承**来源的**原型对象**，这里提到了继承，我们可以看看下面的继承的说明。
用比较奇葩的例子来说的话，我们现在有一只可爱的**警犬（原型链）**，且还有一名罪犯的**臭袜子（原型指针）**，和几个咸鱼人，我们想找到真的** 咸鱼人（原型）**是谁，这时就要通过我们可爱的警犬来寻找咸鱼人了。即通过原型指针（证物）顺着原型链（即通过警犬）找到罪犯（原型对象），问题又来了，罪犯可能不止一个啊。没事，我们不已经找到一个了嘛，通过找出来的罪犯（原型指针），用酷刑逼供（还是顺着原型链）找到新的罪犯（新的原型对象）。这样我们用原型指针来找到原型对象的这种途径（或者称为方法）就是叫原型链。我们通过对象的原型链可以一直找到最初的对象Object.prototype.\__proto\__  即为 NULL ，体现了JavaScript万物皆对象，万物皆空的思想

## 继承

	原型链出现了继承，那什么是继承呢，学过C++/java等有类编程语言的人应该能比较容易的理解，不扯开讲什么是类，我们这里关注点是父类，子类，实例的关系。
先用ES5的语法弄一个简单的原型链继承
```
function Super(){
	this.name = 'ssss'
}
function Child(){}
Child.prototype = new Super()
var instance = new Child()
```
这里又扯到了原型链，就是因为原型链与继承混在一起，他们又是一个抽象的概念让我们比较难以理解。没看懂什么是原型链的话可以去上面再重温下。

这里 Super为父类，Child为子类，通过在子类的原型对象上创建父类的实例来完成一次继承。
我们可以把子类的原型对象看成是一个实例，实例可以通过原型指针(\__proto\__ )找到父类的原型对象(prototype)
```
Child.prototype.__proto__ === Super.prototype //true
//而instance又是Child的实例，所以
instance.__proto__  === Child.prototype //true
instance.__proto__.__proto__  === Super.prototype //true
```
这里我们稍微提下ES5与ES6继承的区别，上面的例子中Child.\__proto\__ 指向谁呢？我们先留个悬念，来看下ES6的继承
```
class  Super{
	constructor(x,y){
		this.x  =  x		
		this.y  =  y
	}
	toString(){
		return  `${this.x} and ${this.y}`
	}
}
class  Child  extends  Super{
	constructor(props){	
		super(props)
	}
	toValue(){
		return  `${this.x} and ${this.y} child`
	}
}
console.log(Child.__proto__ == Super) //true
```
ES5中Child.\__proto\__ （刚才那个悬念）指向function,而ES6中却指向了Super，这是因为ES6继承采取的是**先构造父类对象的实例对象this**，然后子类的构造函数修改this。所以这里ES6的原型指针指向的是Super。而ES5中却是把**实例对象先构造（即先构造Child）**，然后把父类的属性方法添加到子类对象上。因为我们是function Child()创建子类的，所以悬念的答案是function。
再来看下面的例子：
```
	ES5中我们通过了原型链继承有这么一句话
	Child.prototype = new Super()
	所以我们可以很容易理解子类的原型上其实是父类的实例
	Child.prototype.__proto__ === Super.prototype //true
	ES6中子类的原型是父类的实例，所以下面也是成立的
	Child.prototyp.__proto__ === Super.prototype //true
	如果ES5中不使用原型继承呢，比如我们使用构造函数继承
	function Super(){
		this.name = 'sss'
	}
	Super.prototype.sayName = function(){
		console.log(this.name)	
	}
	function Child(){
		Super.call(this)
	}
	var instance = new Child()
	这里的Child.prototyp.__proto__ 为undefined
```
---

用分割线表示我们上面可以分成一类去学习，下面我们来说说作用域与执行上下文。

## 作用域

JavaScript里面是没有块级作用域的说法的（ES6之前，ES6的块级作用域这里不谈），只有函数作用域，我们把最外层函数外的区域叫做全局作用域，函数体内的作用域叫做该函数的局部作用域。而变量根据我们定义的位置来命名它，比如我把变量定义在了全局，它就叫全局作用域，把它定义在某个函数内就叫局部作用域，变量所在的区域内，变量可以被访问操作。全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找， 直至全局作用域，这种组织形式就是作用域链。
有点长也有点似懂非懂，我们可以结合原型链来理解，也可以通过我下面举的奇葩例子来理解：
我们假设整个中国外是全局（比如世界），中国内有好多个省（假设为A级作用域），省内又有好多个城市（B级作用域），城市内又有许多个镇（C级作用域），镇内又有许多个街道（D级作用域）。假设我们现在处于C级，我想找到一个江苏的地名，作用域的规范告诉我们，不能往下找（不允许访问D级），但是本级又找不到（C级），那我们只能往上一级找一下（B级），B级依旧找不到，那我们只能继续往上（A级），好在这里我们找到了江苏！。这就是作用域链，有了原型链的经验我们应该更好理解了。
关于作用域链与原型链的区别我觉得可以这么理解：
作用域我就单纯的往上一级寻找，他们之间的关系不如原型链之间的关系那样**紧密**，毕竟原型链经常和继承混在一起谈。和作用域经常混在一起谈的玩意是执行上下文。

## 执行上下文

执行上下文是我觉得最抽象的东西，什么是上下文，什么又是执行上下文？其实他们都是同一个说法（个人理解），至于把加上执行，是因为它跟执行有密切的关系。
你或许会经常在网上看到这句关于执行上下文的概念：
>当程序运行，进入到某段代码块时，一个新的执行上下文被创建，并被放入一个 stack 中。当程序运行到这段代码块结尾后，对应的执行上下文被弹出 stack。
那么怎么去理解它呢？首先我们把执行上下文看成一个对象：
```
	example{
		VO: // 变量对象
		this: //决定this指向的
		作用域链: //决定作用域链
	}
```
当我们**调用**一个函数时，这个执行上下文就会被创建，并把里面三个属性初始化，对于VO的话建立arguments，检查函数声明，检查变量声明等等，注意**这里不是赋值**。this的话确定this的指向，以及确定好作用域链的范围。等到**执行**函数的时候，才会顺着代码一行一行地给VO对象里的值赋值。等到这个执行完后，把这个执行上下文对象弹出栈。
在全局中执行上下文是长这样的
```
windowEC = {
    VO: window,
    作用域链: {},
    this: window
}
```

### 以上，完，希望这篇文章对大家理解有所帮助。


